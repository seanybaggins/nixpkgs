diff -Naur coreutils-9.8.orig/src/copy-file-data.c coreutils-9.8/src/copy-file-data.c
--- coreutils-9.8.orig/src/copy-file-data.c	2025-11-29 12:48:17.750298972 -0700
+++ coreutils-9.8/src/copy-file-data.c	2025-11-29 13:16:37.701003454 -0700
@@ -28,6 +28,95 @@
 #include "full-write.h"
 #include "ioblksize.h"
 
+/* BEGIN progress mod */
+FILE * spawn( const char *cmd, char *const argv[] )
+{
+    FILE *ret = NULL;
+    int pfd_read[2];
+    pid_t pid;
+
+    if (cmd == NULL || argv == NULL)
+        return ret;
+
+    if (pipe(pfd_read) < 0) {
+        error(0, errno, "pipe: %s", cmd);
+        return ret;
+    }
+
+    if ((pid = fork()) == 0) {
+        int err = dup2(pfd_read[1], 1) < 0;
+        close(pfd_read[0]);
+        close(pfd_read[1]);
+
+        if (err)
+            error(EXIT_FAILURE, errno, "dup2: %s", cmd);
+        execvp(cmd, argv);
+        error(EXIT_FAILURE, errno, "exec: %s", cmd);
+    }
+
+    close(pfd_read[1]);
+
+    if (pid < 0) {
+        close(pfd_read[0]);
+        error(0, errno, "fork: %s", cmd);
+        return ret;
+    }
+
+    ret = fdopen(pfd_read[0], "r");
+    return ret;
+}
+
+void format_time ( char * _cDest, double seconds, bool showall )
+{
+  int hr = ( (int) seconds / (60 * 60)) % 24;
+  int min = ( (int) seconds / 60) % 60;
+  double sec = seconds - (hr * (60 * 60)) - (min * 60);
+  if ( showall )
+  {
+    if ( seconds < 0 )
+      sprintf(_cDest, "%2ch %2cm %2cs", '0', '0', '?');
+    else
+      sprintf(_cDest, "%2dh %2dm %2ds", hr, min, (int) sec);
+  } else  if ( seconds >= 3600 )
+  {
+    sprintf(_cDest, "%2dh %2dm %4.1fs", hr, min, sec);
+  } else if ( seconds >= 60 )
+  {
+    sprintf(_cDest, "%2dm %4.1fs", min, sec);
+  } else
+  {
+    sprintf(_cDest, "%4.1fs", sec);
+  }
+}
+
+int file_size_format ( char * _cDst, long _lSize, int _iCounter )
+{
+  int iCounter = _iCounter;
+  double dSize = ( double ) _lSize;
+  while ( dSize >= 1000. )
+  {
+    dSize /= 1024.;
+    iCounter++;
+  }
+
+  char * sUnit;
+  if ( iCounter == 0 )
+    sUnit = "B";
+  else if ( iCounter == 1 )
+    sUnit = "KiB";
+  else if ( iCounter == 2 )
+    sUnit = "MiB";
+  else if ( iCounter == 3 )
+    sUnit = "GiB";
+  else if ( iCounter == 4 )
+    sUnit = "TiB";
+  else
+    sUnit = "N/A";
+
+  return sprintf ( _cDst, "%5.1f %s", dSize, sUnit );
+}
+/* END progress mod */
+
 /* Result of infer_scantype when it returns LSEEK_SCANTYPE.  */
 struct scan_inference
 {
@@ -117,6 +206,10 @@
              count_t max_n_read, off_t *hole_size,
              struct copy_debug *debug)
 {
+  /* BEGIN progress mod */
+  static int progress_counter = 0;
+  /* END progress mod */
+  
   count_t total_n_read = 0;
 
   if (debug->sparse_detection == COPY_DEBUG_UNKNOWN)
@@ -133,6 +226,57 @@
            (SSIZE_MAX, SIZE_MAX) truncated to a value that is
            surely aligned well.  */
         ssize_t copy_max = MIN (SSIZE_MAX, SIZE_MAX) >> 30 << 30;
+        
+        /* BEGIN progress mod */
+        if (progress && progress_counter++ % 100 == 0) {
+          struct timeval cur_time;
+          gettimeofday(&cur_time, NULL);
+          double elapsed = (cur_time.tv_sec - g_oStartTime.tv_sec) + 
+                          (cur_time.tv_usec - g_oStartTime.tv_usec) / 1000000.0;
+          
+          /* Overall progress bar */
+          char overall_bar[80];
+          memset(overall_bar, ' ', 79);
+          overall_bar[79] = '\0';
+          overall_bar[0] = '[';
+          overall_bar[70] = ']';
+          
+          /* Current file progress bar */
+          char file_bar[80];
+          memset(file_bar, ' ', 79);
+          file_bar[79] = '\0';
+          file_bar[0] = '[';
+          file_bar[70] = ']';
+          
+          /* Calculate overall progress */
+          if (g_iTotalSize > 0) {
+            double overall_percent = (double)(g_iTotalWritten + total_n_read) / (double)g_iTotalSize * 100.0;
+            int overall_pos = (int)((overall_percent / 100.0) * 68);
+            for (int i = 1; i < overall_pos && i < 69; i++) {
+              overall_bar[i] = '=';
+            }
+            if (overall_pos < 69) overall_bar[overall_pos] = '>';
+            sprintf(overall_bar + 72, "%5.1f%%", overall_percent);
+            
+            /* Calculate current file progress */
+            if (g_iFTotalSize > 0) {
+              double file_percent = (double)total_n_read / (double)g_iFTotalSize * 100.0;
+              int file_pos = (int)((file_percent / 100.0) * 68);
+              for (int i = 1; i < file_pos && i < 69; i++) {
+                file_bar[i] = '=';
+              }
+              if (file_pos < 69) file_bar[file_pos] = '>';
+              sprintf(file_bar + 72, "%5.1f%%", file_percent);
+            }
+            
+            printf("\033[2K\rOverall: %s\n\033[2K\rCurrent: %s\n\033[2A", overall_bar, file_bar);
+          } else {
+            printf("\rCopying... %.1fs elapsed", elapsed);
+          }
+          fflush(stdout);
+        }
+        /* END progress mod */
+        
         ssize_t n_copied = copy_file_range (src_fd, nullptr, dest_fd, nullptr,
                                             MIN (max_n_read, copy_max), 0);
         if (n_copied == 0)
@@ -186,6 +330,56 @@
 
   while (0 < max_n_read)
     {
+      /* BEGIN progress mod */
+      if (progress && progress_counter++ % 100 == 0) {
+        struct timeval cur_time;
+        gettimeofday(&cur_time, NULL);
+        double elapsed = (cur_time.tv_sec - g_oStartTime.tv_sec) + 
+                        (cur_time.tv_usec - g_oStartTime.tv_usec) / 1000000.0;
+        
+        /* Overall progress bar */
+        char overall_bar[80];
+        memset(overall_bar, ' ', 79);
+        overall_bar[79] = '\0';
+        overall_bar[0] = '[';
+        overall_bar[70] = ']';
+        
+        /* Current file progress bar */
+        char file_bar[80];
+        memset(file_bar, ' ', 79);
+        file_bar[79] = '\0';
+        file_bar[0] = '[';
+        file_bar[70] = ']';
+        
+        /* Calculate overall progress */
+        if (g_iTotalSize > 0) {
+          double overall_percent = (double)(g_iTotalWritten + total_n_read) / (double)g_iTotalSize * 100.0;
+          int overall_pos = (int)((overall_percent / 100.0) * 68);
+          for (int i = 1; i < overall_pos && i < 69; i++) {
+            overall_bar[i] = '=';
+          }
+          if (overall_pos < 69) overall_bar[overall_pos] = '>';
+          sprintf(overall_bar + 72, "%5.1f%%", overall_percent);
+          
+          /* Calculate current file progress */
+          if (g_iFTotalSize > 0) {
+            double file_percent = (double)total_n_read / (double)g_iFTotalSize * 100.0;
+            int file_pos = (int)((file_percent / 100.0) * 68);
+            for (int i = 1; i < file_pos && i < 69; i++) {
+              file_bar[i] = '=';
+            }
+            if (file_pos < 69) file_bar[file_pos] = '>';
+            sprintf(file_bar + 72, "%5.1f%%", file_percent);
+          }
+          
+          printf("\033[2K\rOverall: %s\n\033[2K\rCurrent: %s\n\033[2A", overall_bar, file_bar);
+        } else {
+          printf("\rCopying... %.1fs elapsed", elapsed);
+        }
+        fflush(stdout);
+      }
+      /* END progress mod */
+      
       if (!*abuf)
         *abuf = xalignalloc (getpagesize (), buf_size);
       char *buf = *abuf;
@@ -518,6 +712,15 @@
                 count_t ibytes, struct cp_options const *x,
                 struct copy_debug *debug)
 {
+  /* BEGIN progress mod */
+  if (progress) {
+    gettimeofday(&g_oStartTime, NULL);
+    g_iFTotalSize = ist->st_size;
+    printf("Copying %s...\n", iname);
+    fflush(stdout);
+  }
+  /* END progress mod */
+  
   /* Choose a suitable buffer size; it may be adjusted later.  */
   idx_t buf_size = io_blksize (ost);
 
@@ -611,5 +814,19 @@
     }
 
   alignfree (buf);
+  
+  /* BEGIN progress mod */
+  if (progress) {
+    /* Update total bytes written */
+    g_iTotalWritten += result;
+    g_iFilesCopied++;
+    
+    /* Clean up progress lines and show completion */
+    printf("\033[2K\rOverall: [================================>     ] completed\n");
+    printf("\033[2K\rCurrent: [==================================] 100.0%%\n");
+    fflush(stdout);
+  }
+  /* END progress mod */
+  
   return result;
 }
diff -Naur coreutils-9.8.orig/src/copy.h coreutils-9.8/src/copy.h
--- coreutils-9.8.orig/src/copy.h	2025-11-29 12:48:17.751298960 -0700
+++ coreutils-9.8/src/copy.h	2025-11-29 12:48:54.745884399 -0700
@@ -255,6 +255,9 @@
      Create destination directories as usual. */
   bool symbolic_link;
 
+  /* If true, draw a nice progress bar on screen */ 
+  bool progress_bar;
+
   /* Control if destination files are replaced.  */
   enum Update_type update;
 
@@ -360,4 +363,21 @@
   _GL_ATTRIBUTE_NONNULL () _GL_ATTRIBUTE_PURE;
 mode_t cached_umask (void);
 
+/* BEGIN progress mod */
+FILE * spawn( const char *cmd, char *const argv[] );
+void format_time ( char * _cDst, double seconds, bool showall );
+int file_size_format ( char * _cDst, long _lSize, int _iCounter );
+
+__attribute__((__common__)) long g_iTotalSize;
+__attribute__((__common__)) long g_iFTotalSize;
+__attribute__((__common__)) long g_iTotalWritten;
+__attribute__((__common__)) long g_iFTotalWritten;
+__attribute__((__common__)) int g_iFilesCopied;
+__attribute__((__common__)) int g_iDirectoriesCopied;
+__attribute__((__common__)) struct timeval g_oStartTime;
+__attribute__((__common__)) struct timeval g_oFStartTime;
+__attribute__((__common__)) int g_iTotalFiles;
+__attribute__((__common__)) bool progress;
+/* END progress mod */
+
 #endif
diff -Naur coreutils-9.8.orig/src/cp.c coreutils-9.8/src/cp.c
--- coreutils-9.8.orig/src/cp.c	2025-11-29 12:48:17.751298960 -0700
+++ coreutils-9.8/src/cp.c	2025-11-29 13:16:55.503964828 -0700
@@ -141,6 +141,7 @@
   {"symbolic-link", no_argument, nullptr, 's'},
   {"target-directory", required_argument, nullptr, 't'},
   {"update", optional_argument, nullptr, 'u'},
+  {"progress-bar", no_argument, nullptr, 'g'},
   {"verbose", no_argument, nullptr, 'v'},
   {"keep-directory-symlink", no_argument, nullptr,
     KEEP_DIRECTORY_SYMLINK_OPTION},
@@ -185,6 +186,9 @@
   -f, --force                  if an existing destination file cannot be\n\
                                  opened, remove it and try again (this option\n\
                                  is ignored when the -n option is also used)\n\
+  -g, --progress-bar           add a progress bar.\n\
+                                 Note that this doesn't work with reflink,\n\
+                                 reflink will be automatically disabled\n\
   -i, --interactive            prompt before overwrite (overrides a previous -n\
 \n\
                                   option)\n\
@@ -682,6 +686,57 @@
         }
     }
 
+    /* BEGIN progress mod */
+    if (progress) {
+        g_iTotalSize = 0;
+        g_iTotalFiles = 0;
+        g_iFilesCopied = 0;
+        g_iDirectoriesCopied = 0;
+        g_iTotalWritten = 0;
+
+        /* save time */
+        struct timeval start_time;
+        gettimeofday(&start_time, NULL);
+        g_oStartTime = start_time;
+
+        printf("calculating total size... \r");
+        fflush(stdout);
+        
+        /* Calculate total size for all files */
+        for (int j = 0; j < n_files - (target_directory ? 0 : 1); j++)
+        {
+          FILE *fp = spawn("du", (char *[]){ "du", "-sb", file[j], NULL });
+          if (fp) {
+            char output[1024];
+            if (fgets(output, sizeof(output)-1, fp)) {
+              char *tab = strchr(output, '\t');
+              if (tab) {
+                *tab = '\0';
+                g_iTotalSize += atol(output);
+              }
+            }
+            pclose(fp);
+          }
+
+          /* Count files */
+          fp = spawn("find", (char *[]){ "find", file[j], "-type", "f", NULL });
+          if (fp) {
+            char *line_buf = NULL;
+            size_t line_buf_size = 0;
+            ssize_t line_size;
+            while ((line_size = getline(&line_buf, &line_buf_size, fp)) > 0) {
+              g_iTotalFiles++;
+            }
+            free(line_buf);
+            pclose(fp);
+          }
+        }
+        
+        printf("Total: %ld files, %ld bytes\n", g_iTotalFiles, g_iTotalSize);
+        fflush(stdout);
+    }
+    /* END progress mod */
+
   if (target_directory)
     {
       /* cp file1...filen edir
@@ -822,6 +877,23 @@
       ok = copy (source, dest, AT_FDCWD, dest, -new_dst, x, &unused, nullptr);
     }
 
+    /* BEGIN progress mod */
+    if (progress) {
+        /* Final cleanup and summary */
+        struct timeval end_time;
+        gettimeofday(&end_time, NULL);
+        double total_elapsed = (end_time.tv_sec - g_oStartTime.tv_sec) + 
+                              (end_time.tv_usec - g_oStartTime.tv_usec) / 1000000.0;
+        
+        char total_size_str[20];
+        file_size_format(total_size_str, g_iTotalSize, 0);
+        
+        printf("\033[2K\rCompleted: %ld files (%s) copied in %.1fs\n", 
+               g_iFilesCopied, total_size_str, total_elapsed);
+        fflush(stdout);
+    }
+    /* END progress mod */
+
   return ok;
 }
 
@@ -857,6 +929,7 @@
   x->recursive = false;
   x->sparse_mode = SPARSE_AUTO;
   x->symbolic_link = false;
+  x->progress_bar = false;
   x->set_mode = false;
   x->mode = 0;
 
@@ -996,7 +1069,7 @@
   selinux_enabled = (0 < is_selinux_enabled ());
   cp_option_init (&x);
 
-  while ((c = getopt_long (argc, argv, "abdfHilLnprst:uvxPRS:TZ",
+  while ((c = getopt_long (argc, argv, "abdfgHilLnprst:uvxPRS:TZ",
                            long_opts, nullptr))
          != -1)
     {
@@ -1057,6 +1130,10 @@
           x.unlink_dest_after_failed_open = true;
           break;
 
+        case 'g': 
+          progress = true; 
+          break; 
+
         case 'H':
           x.dereference = DEREF_COMMAND_LINE_ARGUMENTS;
           break;
@@ -1223,6 +1300,9 @@
       usage (EXIT_FAILURE);
     }
 
+  if (progress)
+    x.reflink_mode = REFLINK_NEVER;
+
   x.backup_type = (make_backups
                    ? xget_version (_("backup type"),
                                    version_control_string)
diff -Naur coreutils-9.8.orig/src/mv.c coreutils-9.8/src/mv.c
--- coreutils-9.8.orig/src/mv.c	2025-11-29 12:48:17.752298948 -0700
+++ coreutils-9.8/src/mv.c	2025-11-29 12:54:31.206849863 -0700
@@ -80,6 +80,7 @@
   {"target-directory", required_argument, nullptr, 't'},
   {"update", optional_argument, nullptr, 'u'},
   {"verbose", no_argument, nullptr, 'v'},
+  {"progress-bar", no_argument, nullptr, 'g'},
   {GETOPT_HELP_OPTION_DECL},
   {GETOPT_VERSION_OPTION_DECL},
   {nullptr, 0, nullptr, 0}
@@ -279,6 +280,7 @@
 "), stdout);
       fputs (_("\
   -f, --force                  do not prompt before overwriting\n\
+  -g, --progress-bar           add progress-bar\n\
   -i, --interactive            prompt before overwrite\n\
   -n, --no-clobber             do not overwrite an existing file\n\
 If you specify more than one of -i, -f, -n, only the final one takes effect.\n\
@@ -341,7 +343,7 @@
   /* Try to disable the ability to unlink a directory.  */
   priv_set_remove_linkdir ();
 
-  while ((c = getopt_long (argc, argv, "bfint:uvS:TZ", long_options, nullptr))
+  while ((c = getopt_long (argc, argv, "bfint:uvgS:TZ", long_options, nullptr))
          != -1)
     {
       switch (c)
@@ -354,6 +356,9 @@
         case 'f':
           x.interactive = I_ALWAYS_YES;
           break;
+        case 'g': 
+          progress = true; 
+          break;
         case 'i':
           x.interactive = I_ASK_USER;
           break;
